
[Fact]
public void {TestType}MarshalSizeTest()
{
    Assert.Equal(8, Marshal.SizeOf<{TestType}>());
    Assert.Equal(8, Marshal.SizeOf<{TestType}>(new {TestType}()));
}

[Fact]
public void {TestType}CopyToTest()
{
    {TestType} v1 = new {TestType}(2.0f, 3.0f);

    float[] a = new float[3];
    float[] b = new float[2];

    Assert.Throws<NullReferenceException>(() => v1.CopyTo(null, 0));
    Assert.Throws<ArgumentOutOfRangeException>(() => v1.CopyTo(a, -1));
    Assert.Throws<ArgumentOutOfRangeException>(() => v1.CopyTo(a, a.Length));
    AssertExtensions.Throws<ArgumentException>(null, () => v1.CopyTo(a, 2));

    v1.CopyTo(a, 1);
    v1.CopyTo(b);
    Assert.Equal(0.0, a[0]);
    Assert.Equal(2.0, a[1]);
    Assert.Equal(3.0, a[2]);
    Assert.Equal(2.0, b[0]);
    Assert.Equal(3.0, b[1]);
}

[Fact]
public void {TestType}GetHashCodeTest()
{
    {TestType} v1 = new {TestType}(2.0f, 3.0f);
    {TestType} v2 = new {TestType}(2.0f, 3.0f);
    {TestType} v3 = new {TestType}(3.0f, 2.0f);
    Assert.Equal(v1.GetHashCode(), v1.GetHashCode());
    Assert.Equal(v1.GetHashCode(), v2.GetHashCode());
    Assert.NotEqual(v1.GetHashCode(), v3.GetHashCode());
    {TestType} v4 = new {TestType}(0.0f, 0.0f);
    {TestType} v6 = new {TestType}(1.0f, 0.0f);
    {TestType} v7 = new {TestType}(0.0f, 1.0f);
    {TestType} v8 = new {TestType}(1.0f, 1.0f);
    Assert.NotEqual(v4.GetHashCode(), v6.GetHashCode());
    Assert.NotEqual(v4.GetHashCode(), v7.GetHashCode());
    Assert.NotEqual(v4.GetHashCode(), v8.GetHashCode());
    Assert.NotEqual(v7.GetHashCode(), v6.GetHashCode());
    Assert.NotEqual(v8.GetHashCode(), v6.GetHashCode());
    Assert.NotEqual(v8.GetHashCode(), v7.GetHashCode());
}

[Fact]
public void {TestType}ToStringTest()
{
    string separator = CultureInfo.CurrentCulture.NumberFormat.NumberGroupSeparator;
    CultureInfo enUsCultureInfo = new CultureInfo("en-US");

    {TestType} v1 = new {TestType}(2.0f, 3.0f);

    string v1str = v1.ToString();
    string expectedv1 = string.Format(CultureInfo.CurrentCulture
        , "<{1:G}{0} {2:G}>"
        , new object[] { separator, 2, 3 });
    Assert.Equal(expectedv1, v1str);

    string v1strformatted = v1.ToString("c", CultureInfo.CurrentCulture);
    string expectedv1formatted = string.Format(CultureInfo.CurrentCulture
        , "<{1:c}{0} {2:c}>"
        , new object[] { separator, 2, 3 });
    Assert.Equal(expectedv1formatted, v1strformatted);

    string v2strformatted = v1.ToString("c", enUsCultureInfo);
    string expectedv2formatted = string.Format(enUsCultureInfo
        , "<{1:c}{0} {2:c}>"
        , new object[] { enUsCultureInfo.NumberFormat.NumberGroupSeparator, 2, 3 });
    Assert.Equal(expectedv2formatted, v2strformatted);

    string v3strformatted = v1.ToString("c");
    string expectedv3formatted = string.Format(CultureInfo.CurrentCulture
        , "<{1:c}{0} {2:c}>"
        , new object[] { separator, 2, 3 });
    Assert.Equal(expectedv3formatted, v3strformatted);
}

// A test for Distance ({TestType}, {TestType})
[Fact]
public void {TestType}DistanceTest()
{
    {TestType} a = new {TestType}(1.0f, 2.0f);
    {TestType} b = new {TestType}(3.0f, 4.0f);

    float expected = (float)System.Math.Sqrt(8);
    float actual;

    actual = {TestType}.Distance(a, b);
    Assert.True(MathHelper.Equal(expected, actual), "{TestType}.Distance did not return the expected value.");
}

// A test for Distance ({TestType}, {TestType})
// Distance from the same point
[Fact]
public void {TestType}DistanceTest2()
{
    {TestType} a = new {TestType}(1.051f, 2.05f);
    {TestType} b = new {TestType}(1.051f, 2.05f);

    float actual = {TestType}.Distance(a, b);
    Assert.Equal(0.0f, actual);
}

// A test for DistanceSquared ({TestType}, {TestType})
[Fact]
public void {TestType}DistanceSquaredTest()
{
    {TestType} a = new {TestType}(1.0f, 2.0f);
    {TestType} b = new {TestType}(3.0f, 4.0f);

    float expected = 8.0f;
    float actual;

    actual = {TestType}.DistanceSquared(a, b);
    Assert.True(MathHelper.Equal(expected, actual), "{TestType}.DistanceSquared did not return the expected value.");
}

// A test for Dot ({TestType}, {TestType})
[Fact]
public void {TestType}DotTest()
{
    {TestType} a = new {TestType}(1.0f, 2.0f);
    {TestType} b = new {TestType}(3.0f, 4.0f);

    float expected = 11.0f;
    float actual;

    actual = {TestType}.Dot(a, b);
    Assert.True(MathHelper.Equal(expected, actual), "{TestType}.Dot did not return the expected value.");
}

// A test for Dot ({TestType}, {TestType})
// Dot test for perpendicular vector
[Fact]
public void {TestType}DotTest1()
{
    {TestType} a = new {TestType}(1.55f, 1.55f);
    {TestType} b = new {TestType}(-1.55f, 1.55f);

    float expected = 0.0f;
    float actual = {TestType}.Dot(a, b);
    Assert.Equal(expected, actual);
}

// A test for Dot ({TestType}, {TestType})
// Dot test with specail float values
[Fact]
public void {TestType}DotTest2()
{
    {TestType} a = new {TestType}(float.MinValue, float.MinValue);
    {TestType} b = new {TestType}(float.MaxValue, float.MaxValue);

    float actual = {TestType}.Dot(a, b);
    Assert.True(float.IsNegativeInfinity(actual), "{TestType}.Dot did not return the expected value.");
}

// A test for Length ()
[Fact]
public void {TestType}LengthTest()
{
    {TestType} a = new {TestType}(2.0f, 4.0f);

    {TestType} target = a;

    float expected = (float)System.Math.Sqrt(20);
    float actual;

    actual = target.Length();

    Assert.True(MathHelper.Equal(expected, actual), "{TestType}.Length did not return the expected value.");
}

// A test for Length ()
// Length test where length is zero
[Fact]
public void {TestType}LengthTest1()
{
    {TestType} target = new {TestType}();
    target.X = 0.0f;
    target.Y = 0.0f;

    float expected = 0.0f;
    float actual;

    actual = target.Length();

    Assert.True(MathHelper.Equal(expected, actual), "{TestType}.Length did not return the expected value.");
}

// A test for LengthSquared ()
[Fact]
public void {TestType}LengthSquaredTest()
{
    {TestType} a = new {TestType}(2.0f, 4.0f);

    {TestType} target = a;

    float expected = 20.0f;
    float actual;

    actual = target.LengthSquared();

    Assert.True(MathHelper.Equal(expected, actual), "{TestType}.LengthSquared did not return the expected value.");
}

// A test for LengthSquared ()
// LengthSquared test where the result is zero
[Fact]
public void {TestType}LengthSquaredTest1()
{
    {TestType} a = new {TestType}(0.0f, 0.0f);

    float expected = 0.0f;
    float actual = a.LengthSquared();

    Assert.Equal(expected, actual);
}

// A test for Min ({TestType}, {TestType})
[Fact]
public void {TestType}MinTest()
{
    {TestType} a = new {TestType}(-1.0f, 4.0f);
    {TestType} b = new {TestType}(2.0f, 1.0f);

    {TestType} expected = new {TestType}(-1.0f, 1.0f);
    {TestType} actual;
    actual = {TestType}.Min(a, b);
    Assert.True(MathHelper.Equal(expected, actual), "{TestType}.Min did not return the expected value.");
}

[Fact]
public void {TestType}MinMaxCodeCoverageTest()
{
    {TestType} min = new {TestType}(0, 0);
    {TestType} max = new {TestType}(1, 1);
    {TestType} actual;

    // Min.
    actual = {TestType}.Min(min, max);
    Assert.Equal(actual, min);

    actual = {TestType}.Min(max, min);
    Assert.Equal(actual, min);

    // Max.
    actual = {TestType}.Max(min, max);
    Assert.Equal(actual, max);

    actual = {TestType}.Max(max, min);
    Assert.Equal(actual, max);
}

// A test for Max ({TestType}, {TestType})
[Fact]
public void {TestType}MaxTest()
{
    {TestType} a = new {TestType}(-1.0f, 4.0f);
    {TestType} b = new {TestType}(2.0f, 1.0f);

    {TestType} expected = new {TestType}(2.0f, 4.0f);
    {TestType} actual;
    actual = {TestType}.Max(a, b);
    Assert.True(MathHelper.Equal(expected, actual), "{TestType}.Max did not return the expected value.");
}

// A test for Clamp ({TestType}, {TestType}, {TestType})
[Fact]
public void {TestType}ClampTest()
{
    {TestType} a = new {TestType}(0.5f, 0.3f);
    {TestType} min = new {TestType}(0.0f, 0.1f);
    {TestType} max = new {TestType}(1.0f, 1.1f);

    // Normal case.
    // Case N1: specified value is in the range.
    {TestType} expected = new {TestType}(0.5f, 0.3f);
    {TestType} actual = {TestType}.Clamp(a, min, max);
    Assert.True(MathHelper.Equal(expected, actual), "{TestType}.Clamp did not return the expected value.");
    // Normal case.
    // Case N2: specified value is bigger than max value.
    a = new {TestType}(2.0f, 3.0f);
    expected = max;
    actual = {TestType}.Clamp(a, min, max);
    Assert.True(MathHelper.Equal(expected, actual), "{TestType}.Clamp did not return the expected value.");
    // Case N3: specified value is smaller than max value.
    a = new {TestType}(-1.0f, -2.0f);
    expected = min;
    actual = {TestType}.Clamp(a, min, max);
    Assert.True(MathHelper.Equal(expected, actual), "{TestType}.Clamp did not return the expected value.");
    // Case N4: combination case.
    a = new {TestType}(-2.0f, 4.0f);
    expected = new {TestType}(min.X, max.Y);
    actual = {TestType}.Clamp(a, min, max);
    Assert.True(MathHelper.Equal(expected, actual), "{TestType}.Clamp did not return the expected value.");
    // User specified min value is bigger than max value.
    max = new {TestType}(0.0f, 0.1f);
    min = new {TestType}(1.0f, 1.1f);

    // Case W1: specified value is in the range.
    a = new {TestType}(0.5f, 0.3f);
    expected = max;
    actual = {TestType}.Clamp(a, min, max);
    Assert.True(MathHelper.Equal(expected, actual), "{TestType}.Clamp did not return the expected value.");

    // Normal case.
    // Case W2: specified value is bigger than max and min value.
    a = new {TestType}(2.0f, 3.0f);
    expected = max;
    actual = {TestType}.Clamp(a, min, max);
    Assert.True(MathHelper.Equal(expected, actual), "{TestType}.Clamp did not return the expected value.");

    // Case W3: specified value is smaller than min and max value.
    a = new {TestType}(-1.0f, -2.0f);
    expected = max;
    actual = {TestType}.Clamp(a, min, max);
    Assert.True(MathHelper.Equal(expected, actual), "{TestType}.Clamp did not return the expected value.");
}

// A test for Lerp ({TestType}, {TestType}, float)
[Fact]
public void {TestType}LerpTest()
{
    {TestType} a = new {TestType}(1.0f, 2.0f);
    {TestType} b = new {TestType}(3.0f, 4.0f);

    float t = 0.5f;

    {TestType} expected = new {TestType}(2.0f, 3.0f);
    {TestType} actual;
    actual = {TestType}.Lerp(a, b, t);
    Assert.True(MathHelper.Equal(expected, actual), "{TestType}.Lerp did not return the expected value.");
}

// A test for Lerp ({TestType}, {TestType}, float)
// Lerp test with factor zero
[Fact]
public void {TestType}LerpTest1()
{
    {TestType} a = new {TestType}(0.0f, 0.0f);
    {TestType} b = new {TestType}(3.18f, 4.25f);

    float t = 0.0f;
    {TestType} expected = {TestType}.Zero;
    {TestType} actual = {TestType}.Lerp(a, b, t);
    Assert.True(MathHelper.Equal(expected, actual), "{TestType}.Lerp did not return the expected value.");
}

// A test for Lerp ({TestType}, {TestType}, float)
// Lerp test with factor one
[Fact]
public void {TestType}LerpTest2()
{
    {TestType} a = new {TestType}(0.0f, 0.0f);
    {TestType} b = new {TestType}(3.18f, 4.25f);

    float t = 1.0f;
    {TestType} expected = new {TestType}(3.18f, 4.25f);
    {TestType} actual = {TestType}.Lerp(a, b, t);
    Assert.True(MathHelper.Equal(expected, actual), "{TestType}.Lerp did not return the expected value.");
}

// A test for Lerp ({TestType}, {TestType}, float)
// Lerp test with factor > 1
[Fact]
public void {TestType}LerpTest3()
{
    {TestType} a = new {TestType}(0.0f, 0.0f);
    {TestType} b = new {TestType}(3.18f, 4.25f);

    float t = 2.0f;
    {TestType} expected = b * 2.0f;
    {TestType} actual = {TestType}.Lerp(a, b, t);
    Assert.True(MathHelper.Equal(expected, actual), "{TestType}.Lerp did not return the expected value.");
}

// A test for Lerp ({TestType}, {TestType}, float)
// Lerp test with factor < 0
[Fact]
public void {TestType}LerpTest4()
{
    {TestType} a = new {TestType}(0.0f, 0.0f);
    {TestType} b = new {TestType}(3.18f, 4.25f);

    float t = -2.0f;
    {TestType} expected = -(b * 2.0f);
    {TestType} actual = {TestType}.Lerp(a, b, t);
    Assert.True(MathHelper.Equal(expected, actual), "{TestType}.Lerp did not return the expected value.");
}

// A test for Lerp ({TestType}, {TestType}, float)
// Lerp test with special float value
[Fact]
public void {TestType}LerpTest5()
{
    {TestType} a = new {TestType}(45.67f, 90.0f);
    {TestType} b = new {TestType}(float.PositiveInfinity, float.NegativeInfinity);

    float t = 0.408f;
    {TestType} actual = {TestType}.Lerp(a, b, t);
    Assert.True(float.IsPositiveInfinity(actual.X), "{TestType}.Lerp did not return the expected value.");
    Assert.True(float.IsNegativeInfinity(actual.Y), "{TestType}.Lerp did not return the expected value.");
}

// A test for Lerp ({TestType}, {TestType}, float)
// Lerp test from the same point
[Fact]
public void {TestType}LerpTest6()
{
    {TestType} a = new {TestType}(1.0f, 2.0f);
    {TestType} b = new {TestType}(1.0f, 2.0f);

    float t = 0.5f;

    {TestType} expected = new {TestType}(1.0f, 2.0f);
    {TestType} actual = {TestType}.Lerp(a, b, t);
    Assert.True(MathHelper.Equal(expected, actual), "{TestType}.Lerp did not return the expected value.");
}

// A test for Lerp ({TestType}, {TestType}, float)
// Lerp test with values known to be innacurate with the old lerp impl
[Fact]
public void {TestType}LerpTest7()
{
    {TestType} a = new {TestType}(0.44728136f);
    {TestType} b = new {TestType}(0.46345946f);

    float t = 0.26402435f;

    {TestType} expected = new {TestType}(0.45155275f);
    {TestType} actual = {TestType}.Lerp(a, b, t);
    Assert.True(MathHelper.Equal(expected, actual), "{TestType}.Lerp did not return the expected value.");
}

// A test for Lerp ({TestType}, {TestType}, float)
// Lerp test with values known to be innacurate with the old lerp impl
// (Old code incorrectly gets 0.33333588)
[Fact]
public void {TestType}LerpTest8()
{
    {TestType} a = new {TestType}(-100);
    {TestType} b = new {TestType}(0.33333334f);

    float t = 1f;

    {TestType} expected = new {TestType}(0.33333334f);
    {TestType} actual = {TestType}.Lerp(a, b, t);
    Assert.True(MathHelper.Equal(expected, actual), "{TestType}.Lerp did not return the expected value.");
}

// A test for Transform({TestType}, Matrix4x4)
[Fact]
public void {TestType}TransformTest()
{
    {TestType} v = new {TestType}(1.0f, 2.0f);
    Matrix4x4 m =
        Matrix4x4.CreateRotationX(MathHelper.ToRadians(30.0f)) *
        Matrix4x4.CreateRotationY(MathHelper.ToRadians(30.0f)) *
        Matrix4x4.CreateRotationZ(MathHelper.ToRadians(30.0f));
    m.M41 = 10.0f;
    m.M42 = 20.0f;
    m.M43 = 30.0f;

    {TestType} expected = new {TestType}(10.316987f, 22.183012f);
    {TestType} actual;

    actual = {TestType}.Transform(v, m);
    Assert.True(MathHelper.Equal(expected, actual), "{TestType}.Transform did not return the expected value.");
}

// A test for Transform({TestType}, Matrix3x2)
[Fact]
public void {TestType}Transform3x2Test()
{
    {TestType} v = new {TestType}(1.0f, 2.0f);
    Matrix3x2 m = Matrix3x2.CreateRotation(MathHelper.ToRadians(30.0f));
    m.M31 = 10.0f;
    m.M32 = 20.0f;

    {TestType} expected = new {TestType}(9.866025f, 22.23205f);
    {TestType} actual;

    actual = {TestType}.Transform(v, m);
    Assert.True(MathHelper.Equal(expected, actual), "{TestType}.Transform did not return the expected value.");
}

// A test for TransformNormal ({TestType}, Matrix4x4)
[Fact]
public void {TestType}TransformNormalTest()
{
    {TestType} v = new {TestType}(1.0f, 2.0f);
    Matrix4x4 m =
        Matrix4x4.CreateRotationX(MathHelper.ToRadians(30.0f)) *
        Matrix4x4.CreateRotationY(MathHelper.ToRadians(30.0f)) *
        Matrix4x4.CreateRotationZ(MathHelper.ToRadians(30.0f));
    m.M41 = 10.0f;
    m.M42 = 20.0f;
    m.M43 = 30.0f;

    {TestType} expected = new {TestType}(0.3169873f, 2.18301272f);
    {TestType} actual;

    actual = {TestType}.TransformNormal(v, m);
    Assert.True(MathHelper.Equal(expected, actual), "{TestType}.Tranform did not return the expected value.");
}

// A test for TransformNormal ({TestType}, Matrix3x2)
[Fact]
public void {TestType}TransformNormal3x2Test()
{
    {TestType} v = new {TestType}(1.0f, 2.0f);
    Matrix3x2 m = Matrix3x2.CreateRotation(MathHelper.ToRadians(30.0f));
    m.M31 = 10.0f;
    m.M32 = 20.0f;

    {TestType} expected = new {TestType}(-0.133974612f, 2.232051f);
    {TestType} actual;

    actual = {TestType}.TransformNormal(v, m);
    Assert.True(MathHelper.Equal(expected, actual), "{TestType}.Transform did not return the expected value.");
}

// A test for Transform ({TestType}, Quaternion)
[Fact]
public void {TestType}TransformByQuaternionTest()
{
    {TestType} v = new {TestType}(1.0f, 2.0f);

    Matrix4x4 m =
        Matrix4x4.CreateRotationX(MathHelper.ToRadians(30.0f)) *
        Matrix4x4.CreateRotationY(MathHelper.ToRadians(30.0f)) *
        Matrix4x4.CreateRotationZ(MathHelper.ToRadians(30.0f));
    Quaternion q = Quaternion.CreateFromRotationMatrix(m);

    {TestType} expected = {TestType}.Transform(v, m);
    {TestType} actual = {TestType}.Transform(v, q);
    Assert.True(MathHelper.Equal(expected, actual), "{TestType}.Transform did not return the expected value.");
}

// A test for Transform ({TestType}, Quaternion)
// Transform {TestType} with zero quaternion
[Fact]
public void {TestType}TransformByQuaternionTest1()
{
    {TestType} v = new {TestType}(1.0f, 2.0f);
    Quaternion q = new Quaternion();
    {TestType} expected = v;

    {TestType} actual = {TestType}.Transform(v, q);
    Assert.True(MathHelper.Equal(expected, actual), "{TestType}.Transform did not return the expected value.");
}

// A test for Transform ({TestType}, Quaternion)
// Transform {TestType} with identity quaternion
[Fact]
public void {TestType}TransformByQuaternionTest2()
{
    {TestType} v = new {TestType}(1.0f, 2.0f);
    Quaternion q = Quaternion.Identity;
    {TestType} expected = v;

    {TestType} actual = {TestType}.Transform(v, q);
    Assert.True(MathHelper.Equal(expected, actual), "{TestType}.Transform did not return the expected value.");
}

// A test for Normalize ({TestType})
[Fact]
public void {TestType}NormalizeTest()
{
    {TestType} a = new {TestType}(2.0f, 3.0f);
    {TestType} expected = new {TestType}(0.554700196225229122018341733457f, 0.8320502943378436830275126001855f);
    {TestType} actual;

    actual = {TestType}.Normalize(a);
    Assert.True(MathHelper.Equal(expected, actual), "{TestType}.Normalize did not return the expected value.");
}

// A test for Normalize ({TestType})
// Normalize zero length vector
[Fact]
public void {TestType}NormalizeTest1()
{
    {TestType} a = new {TestType}(); // no parameter, default to 0.0f
    {TestType} actual = {TestType}.Normalize(a);
    Assert.True(float.IsNaN(actual.X) && float.IsNaN(actual.Y), "{TestType}.Normalize did not return the expected value.");
}

// A test for Normalize ({TestType})
// Normalize infinite length vector
[Fact]
public void {TestType}NormalizeTest2()
{
    {TestType} a = new {TestType}(float.MaxValue, float.MaxValue);
    {TestType} actual = {TestType}.Normalize(a);
    {TestType} expected = new {TestType}(0, 0);
    Assert.Equal(expected, actual);
}

// A test for operator - ({TestType})
[Fact]
public void {TestType}UnaryNegationTest()
{
    {TestType} a = new {TestType}(1.0f, 2.0f);

    {TestType} expected = new {TestType}(-1.0f, -2.0f);
    {TestType} actual;

    actual = -a;

    Assert.True(MathHelper.Equal(expected, actual), "{TestType}.operator - did not return the expected value.");
}



// A test for operator - ({TestType})
// Negate test with special float value
[Fact]
public void {TestType}UnaryNegationTest1()
{
    {TestType} a = new {TestType}(float.PositiveInfinity, float.NegativeInfinity);

    {TestType} actual = -a;

    Assert.True(float.IsNegativeInfinity(actual.X), "{TestType}.operator - did not return the expected value.");
    Assert.True(float.IsPositiveInfinity(actual.Y), "{TestType}.operator - did not return the expected value.");
}

// A test for operator - ({TestType})
// Negate test with special float value
[Fact]
public void {TestType}UnaryNegationTest2()
{
    {TestType} a = new {TestType}(float.NaN, 0.0f);
    {TestType} actual = -a;

    Assert.True(float.IsNaN(actual.X), "{TestType}.operator - did not return the expected value.");
    Assert.True(float.Equals(0.0f, actual.Y), "{TestType}.operator - did not return the expected value.");
}

// A test for operator - ({TestType}, {TestType})
[Fact]
public void {TestType}SubtractionTest()
{
    {TestType} a = new {TestType}(1.0f, 3.0f);
    {TestType} b = new {TestType}(2.0f, 1.5f);

    {TestType} expected = new {TestType}(-1.0f, 1.5f);
    {TestType} actual;

    actual = a - b;

    Assert.True(MathHelper.Equal(expected, actual), "{TestType}.operator - did not return the expected value.");
}

// A test for operator * ({TestType}, float)
[Fact]
public void {TestType}MultiplyOperatorTest()
{
    {TestType} a = new {TestType}(2.0f, 3.0f);
    const float factor = 2.0f;

    {TestType} expected = new {TestType}(4.0f, 6.0f);
    {TestType} actual;

    actual = a * factor;
    Assert.True(MathHelper.Equal(expected, actual), "{TestType}.operator * did not return the expected value.");
}

// A test for operator * (float, {TestType})
[Fact]
public void {TestType}MultiplyOperatorTest2()
{
    {TestType} a = new {TestType}(2.0f, 3.0f);
    const float factor = 2.0f;

    {TestType} expected = new {TestType}(4.0f, 6.0f);
    {TestType} actual;

    actual = factor * a;
    Assert.True(MathHelper.Equal(expected, actual), "{TestType}.operator * did not return the expected value.");
}

// A test for operator * ({TestType}, {TestType})
[Fact]
public void {TestType}MultiplyOperatorTest3()
{
    {TestType} a = new {TestType}(2.0f, 3.0f);
    {TestType} b = new {TestType}(4.0f, 5.0f);

    {TestType} expected = new {TestType}(8.0f, 15.0f);
    {TestType} actual;

    actual = a * b;

    Assert.True(MathHelper.Equal(expected, actual), "{TestType}.operator * did not return the expected value.");
}

// A test for operator / ({TestType}, float)
[Fact]
public void {TestType}DivisionTest()
{
    {TestType} a = new {TestType}(2.0f, 3.0f);

    float div = 2.0f;

    {TestType} expected = new {TestType}(1.0f, 1.5f);
    {TestType} actual;

    actual = a / div;

    Assert.True(MathHelper.Equal(expected, actual), "{TestType}.operator / did not return the expected value.");
}

// A test for operator / ({TestType}, {TestType})
[Fact]
public void {TestType}DivisionTest1()
{
    {TestType} a = new {TestType}(2.0f, 3.0f);
    {TestType} b = new {TestType}(4.0f, 5.0f);

    {TestType} expected = new {TestType}(2.0f / 4.0f, 3.0f / 5.0f);
    {TestType} actual;

    actual = a / b;

    Assert.True(MathHelper.Equal(expected, actual), "{TestType}.operator / did not return the expected value.");
}

// A test for operator / ({TestType}, float)
// Divide by zero
[Fact]
public void {TestType}DivisionTest2()
{
    {TestType} a = new {TestType}(-2.0f, 3.0f);

    float div = 0.0f;

    {TestType} actual = a / div;

    Assert.True(float.IsNegativeInfinity(actual.X), "{TestType}.operator / did not return the expected value.");
    Assert.True(float.IsPositiveInfinity(actual.Y), "{TestType}.operator / did not return the expected value.");
}

// A test for operator / ({TestType}, {TestType})
// Divide by zero
[Fact]
public void {TestType}DivisionTest3()
{
    {TestType} a = new {TestType}(0.047f, -3.0f);
    {TestType} b = new {TestType}();

    {TestType} actual = a / b;

    Assert.True(float.IsInfinity(actual.X), "{TestType}.operator / did not return the expected value.");
    Assert.True(float.IsInfinity(actual.Y), "{TestType}.operator / did not return the expected value.");
}

// A test for operator + ({TestType}, {TestType})
[Fact]
public void {TestType}AdditionTest()
{
    {TestType} a = new {TestType}(1.0f, 2.0f);
    {TestType} b = new {TestType}(3.0f, 4.0f);

    {TestType} expected = new {TestType}(4.0f, 6.0f);
    {TestType} actual;

    actual = a + b;

    Assert.True(MathHelper.Equal(expected, actual), "{TestType}.operator + did not return the expected value.");
}

// A test for {TestType} (float, float)
[Fact]
public void {TestType}ConstructorTest()
{
    float x = 1.0f;
    float y = 2.0f;

    {TestType} target = new {TestType}(x, y);
    Assert.True(MathHelper.Equal(target.X, x) && MathHelper.Equal(target.Y, y), "{TestType}(x,y) constructor did not return the expected value.");
}

// A test for {TestType} ()
// Constructor with no parameter
[Fact]
public void {TestType}ConstructorTest2()
{
    {TestType} target = new {TestType}();
    Assert.Equal(0.0f, target.X);
    Assert.Equal(0.0f, target.Y);
}

// A test for {TestType} (float, float)
// Constructor with special floating values
[Fact]
public void {TestType}ConstructorTest3()
{
    {TestType} target = new {TestType}(float.NaN, float.MaxValue);
    Assert.Equal(target.X, float.NaN);
    Assert.Equal(target.Y, float.MaxValue);
}

// A test for {TestType} (float)
[Fact]
public void {TestType}ConstructorTest4()
{
    float value = 1.0f;
    {TestType} target = new {TestType}(value);

    {TestType} expected = new {TestType}(value, value);
    Assert.Equal(expected, target);

    value = 2.0f;
    target = new {TestType}(value);
    expected = new {TestType}(value, value);
    Assert.Equal(expected, target);
}

// A test for Add ({TestType}, {TestType})
[Fact]
public void {TestType}AddTest()
{
    {TestType} a = new {TestType}(1.0f, 2.0f);
    {TestType} b = new {TestType}(5.0f, 6.0f);

    {TestType} expected = new {TestType}(6.0f, 8.0f);
    {TestType} actual;

    actual = {TestType}.Add(a, b);
    Assert.Equal(expected, actual);
}

// A test for Divide ({TestType}, float)
[Fact]
public void {TestType}DivideTest()
{
    {TestType} a = new {TestType}(1.0f, 2.0f);
    float div = 2.0f;
    {TestType} expected = new {TestType}(0.5f, 1.0f);
    {TestType} actual;
    actual = {TestType}.Divide(a, div);
    Assert.Equal(expected, actual);
}

// A test for Divide ({TestType}, {TestType})
[Fact]
public void {TestType}DivideTest1()
{
    {TestType} a = new {TestType}(1.0f, 6.0f);
    {TestType} b = new {TestType}(5.0f, 2.0f);

    {TestType} expected = new {TestType}(1.0f / 5.0f, 6.0f / 2.0f);
    {TestType} actual;

    actual = {TestType}.Divide(a, b);
    Assert.Equal(expected, actual);
}

// A test for Equals (object)
[Fact]
public void {TestType}EqualsTest()
{
    {TestType} a = new {TestType}(1.0f, 2.0f);
    {TestType} b = new {TestType}(1.0f, 2.0f);

    // case 1: compare between same values
    object obj = b;

    bool expected = true;
    bool actual = a.Equals(obj);
    Assert.Equal(expected, actual);

    // case 2: compare between different values
    b.X = 10.0f;
    obj = b;
    expected = false;
    actual = a.Equals(obj);
    Assert.Equal(expected, actual);

    // case 3: compare between different types.
    obj = new Quaternion();
    expected = false;
    actual = a.Equals(obj);
    Assert.Equal(expected, actual);

    // case 3: compare against null.
    obj = null;
    expected = false;
    actual = a.Equals(obj);
    Assert.Equal(expected, actual);
}

// A test for Multiply ({TestType}, float)
[Fact]
public void {TestType}MultiplyTest()
{
    {TestType} a = new {TestType}(1.0f, 2.0f);
    const float factor = 2.0f;
    {TestType} expected = new {TestType}(2.0f, 4.0f);
    {TestType} actual = {TestType}.Multiply(a, factor);
    Assert.Equal(expected, actual);
}

// A test for Multiply (float, {TestType})
[Fact]
public void {TestType}MultiplyTest2()
{
    {TestType} a = new {TestType}(1.0f, 2.0f);
    const float factor = 2.0f;
    {TestType} expected = new {TestType}(2.0f, 4.0f);
    {TestType} actual = {TestType}.Multiply(factor, a);
    Assert.Equal(expected, actual);
}

// A test for Multiply ({TestType}, {TestType})
[Fact]
public void {TestType}MultiplyTest3()
{
    {TestType} a = new {TestType}(1.0f, 2.0f);
    {TestType} b = new {TestType}(5.0f, 6.0f);

    {TestType} expected = new {TestType}(5.0f, 12.0f);
    {TestType} actual;

    actual = {TestType}.Multiply(a, b);
    Assert.Equal(expected, actual);
}

// A test for Negate ({TestType})
[Fact]
public void {TestType}NegateTest()
{
    {TestType} a = new {TestType}(1.0f, 2.0f);

    {TestType} expected = new {TestType}(-1.0f, -2.0f);
    {TestType} actual;

    actual = {TestType}.Negate(a);
    Assert.Equal(expected, actual);
}

// A test for operator != ({TestType}, {TestType})
[Fact]
public void {TestType}InequalityTest()
{
    {TestType} a = new {TestType}(1.0f, 2.0f);
    {TestType} b = new {TestType}(1.0f, 2.0f);

    // case 1: compare between same values
    bool expected = false;
    bool actual = a != b;
    Assert.Equal(expected, actual);

    // case 2: compare between different values
    b.X = 10.0f;
    expected = true;
    actual = a != b;
    Assert.Equal(expected, actual);
}

// A test for operator == ({TestType}, {TestType})
[Fact]
public void {TestType}EqualityTest()
{
    {TestType} a = new {TestType}(1.0f, 2.0f);
    {TestType} b = new {TestType}(1.0f, 2.0f);

    // case 1: compare between same values
    bool expected = true;
    bool actual = a == b;
    Assert.Equal(expected, actual);

    // case 2: compare between different values
    b.X = 10.0f;
    expected = false;
    actual = a == b;
    Assert.Equal(expected, actual);
}

// A test for Subtract ({TestType}, {TestType})
[Fact]
public void {TestType}SubtractTest()
{
    {TestType} a = new {TestType}(1.0f, 6.0f);
    {TestType} b = new {TestType}(5.0f, 2.0f);

    {TestType} expected = new {TestType}(-4.0f, 4.0f);
    {TestType} actual;

    actual = {TestType}.Subtract(a, b);
    Assert.Equal(expected, actual);
}

// A test for UnitX
[Fact]
public void {TestType}UnitXTest()
{
    {TestType} val = new {TestType}(1.0f, 0.0f);
    Assert.Equal(val, {TestType}.UnitX);
}

// A test for UnitY
[Fact]
public void {TestType}UnitYTest()
{
    {TestType} val = new {TestType}(0.0f, 1.0f);
    Assert.Equal(val, {TestType}.UnitY);
}

// A test for One
[Fact]
public void {TestType}OneTest()
{
    {TestType} val = new {TestType}(1.0f, 1.0f);
    Assert.Equal(val, {TestType}.One);
}

// A test for Zero
[Fact]
public void {TestType}ZeroTest()
{
    {TestType} val = new {TestType}(0.0f, 0.0f);
    Assert.Equal(val, {TestType}.Zero);
}

// A test for Equals ({TestType})
[Fact]
public void {TestType}EqualsTest1()
{
    {TestType} a = new {TestType}(1.0f, 2.0f);
    {TestType} b = new {TestType}(1.0f, 2.0f);

    // case 1: compare between same values
    bool expected = true;
    bool actual = a.Equals(b);
    Assert.Equal(expected, actual);

    // case 2: compare between different values
    b.X = 10.0f;
    expected = false;
    actual = a.Equals(b);
    Assert.Equal(expected, actual);
}

// A test for {TestType} comparison involving NaN values
[Fact]
public void {TestType}EqualsNanTest()
{
    {TestType} a = new {TestType}(float.NaN, 0);
    {TestType} b = new {TestType}(0, float.NaN);

    Assert.False(a == {TestType}.Zero);
    Assert.False(b == {TestType}.Zero);

    Assert.True(a != {TestType}.Zero);
    Assert.True(b != {TestType}.Zero);

    Assert.False(a.Equals({TestType}.Zero));
    Assert.False(b.Equals({TestType}.Zero));

    // Counterintuitive result - IEEE rules for NaN comparison are weird!
    Assert.False(a.Equals(a));
    Assert.False(b.Equals(b));
}

// A test for Reflect ({TestType}, {TestType})
[Fact]
public void {TestType}ReflectTest()
{
    {TestType} a = {TestType}.Normalize(new {TestType}(1.0f, 1.0f));

    // Reflect on XZ plane.
    {TestType} n = new {TestType}(0.0f, 1.0f);
    {TestType} expected = new {TestType}(a.X, -a.Y);
    {TestType} actual = {TestType}.Reflect(a, n);
    Assert.True(MathHelper.Equal(expected, actual), "{TestType}.Reflect did not return the expected value.");

    // Reflect on XY plane.
    n = new {TestType}(0.0f, 0.0f);
    expected = new {TestType}(a.X, a.Y);
    actual = {TestType}.Reflect(a, n);
    Assert.True(MathHelper.Equal(expected, actual), "{TestType}.Reflect did not return the expected value.");

    // Reflect on YZ plane.
    n = new {TestType}(1.0f, 0.0f);
    expected = new {TestType}(-a.X, a.Y);
    actual = {TestType}.Reflect(a, n);
    Assert.True(MathHelper.Equal(expected, actual), "{TestType}.Reflect did not return the expected value.");
}

// A test for Reflect ({TestType}, {TestType})
// Reflection when normal and source are the same
[Fact]
public void {TestType}ReflectTest1()
{
    {TestType} n = new {TestType}(0.45f, 1.28f);
    n = {TestType}.Normalize(n);
    {TestType} a = n;

    {TestType} expected = -n;
    {TestType} actual = {TestType}.Reflect(a, n);
    Assert.True(MathHelper.Equal(expected, actual), "{TestType}.Reflect did not return the expected value.");
}

// A test for Reflect ({TestType}, {TestType})
// Reflection when normal and source are negation
[Fact]
public void {TestType}ReflectTest2()
{
    {TestType} n = new {TestType}(0.45f, 1.28f);
    n = {TestType}.Normalize(n);
    {TestType} a = -n;

    {TestType} expected = n;
    {TestType} actual = {TestType}.Reflect(a, n);
    Assert.True(MathHelper.Equal(expected, actual), "{TestType}.Reflect did not return the expected value.");
}

[Fact]
public void {TestType}AbsTest()
{
    {TestType} v1 = new {TestType}(-2.5f, 2.0f);
    {TestType} v3 = {TestType}.Abs(new {TestType}(0.0f, float.NegativeInfinity));
    {TestType} v = {TestType}.Abs(v1);
    Assert.Equal(2.5f, v.X);
    Assert.Equal(2.0f, v.Y);
    Assert.Equal(0.0f, v3.X);
    Assert.Equal(float.PositiveInfinity, v3.Y);
}

[Fact]
public void {TestType}SqrtTest()
{
    {TestType} v1 = new {TestType}(-2.5f, 2.0f);
    {TestType} v2 = new {TestType}(5.5f, 4.5f);
    Assert.Equal(2, (int){TestType}.SquareRoot(v2).X);
    Assert.Equal(2, (int){TestType}.SquareRoot(v2).Y);
    Assert.Equal(float.NaN, {TestType}.SquareRoot(v1).X);
}

// A test to make sure these types are blittable directly into GPU buffer memory layouts
[Fact]
public unsafe void {TestType}SizeofTest()
{
    Assert.Equal(8, sizeof({TestType}));
    Assert.Equal(16, sizeof({TestType}_2x));
    Assert.Equal(12, sizeof({TestType}PlusFloat));
    Assert.Equal(24, sizeof({TestType}PlusFloat_2x));
}

[StructLayout(LayoutKind.Sequential)]
struct {TestType}_2x
{
    private {TestType} _a;
    private {TestType} _b;
}

[StructLayout(LayoutKind.Sequential)]
struct {TestType}PlusFloat
{
    private {TestType} _v;
    private float _f;
}

[StructLayout(LayoutKind.Sequential)]
struct {TestType}PlusFloat_2x
{
    private {TestType}PlusFloat _a;
    private {TestType}PlusFloat _b;
}

[Fact]
public void SetFieldsTest()
{
    {TestType} v3 = new {TestType}(4f, 5f);
    v3.X = 1.0f;
    v3.Y = 2.0f;
    Assert.Equal(1.0f, v3.X);
    Assert.Equal(2.0f, v3.Y);
    {TestType} v4 = v3;
    v4.Y = 0.5f;
    Assert.Equal(1.0f, v4.X);
    Assert.Equal(0.5f, v4.Y);
    Assert.Equal(2.0f, v3.Y);
}

[Fact]
public void EmbeddedVectorSetFields()
{
    EmbeddedVectorObject evo = new EmbeddedVectorObject();
    evo.FieldVector.X = 5.0f;
    evo.FieldVector.Y = 5.0f;
    Assert.Equal(5.0f, evo.FieldVector.X);
    Assert.Equal(5.0f, evo.FieldVector.Y);
}

private class EmbeddedVectorObject
{
    public {TestType} FieldVector;
}
